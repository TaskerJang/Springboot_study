# 07_테스트 코드 작성하기

## 1. 테스트 코드를 작성하는 이유

- 개발 과정에서 문제를 미리 발견할 수 있습니다.

- 리팩토링의 리스크가 줄어듭니다.

- 애플리케이션을 가동해서 직접 테스트하는 것보다 테스트를 빠르게 진행할 수 있습니다.

- 하나의 명세 문서로서의 기능을 수행합니다.

- 몇 가지 프레임워크에 맞춰 테스트 코드를 작성하면 좋은 코드를 생산할 수 있습니다.

- 코드가 작성된 목적을 명확하게 표현할 수 있으며 불필요한 내용이 추가되는 것을 방지합니다.

## 2. 단위 테스트와 통합 테스트

테스트 대상 범위를 기준으로 구분하면 크게 단위 테스트와 통합 테스트로 구분됩니다.

- 단위 테스트: 애플리케이션의 개별 모듈을 독립적으로 테스트하는 방식입니다.
- 통합 테스트: 애플리케이션을 구성하는 다양한 모듈을 결합해 전체적인 로직이 의도한 대로 동작하는지 테스트하는 방식입니다.

## 3. 단위 테스트의 특징

일반적으로 메서드 단위로 테스트를 수행하게 되며 메서드 호출을 통해 의도한 결과 값이 나오는지 확인하는 수준으로 테스트를 진행합니다. 단위 테스트는 비용이 적게 들기 때문에 테스트 피드백을 빠르게 받을 수 있습니다. 데이터베이스나 네트워크 같은 외부 요인들을 제외하고 진행합니다.

## 4. 통합 테스트의 특징

통합 테스트는 모듈을 통합하는 과정에서의 호환성 등을 포함해 애플리케이션이 정상적으로 동작하는지 확인하기 위해 수행하는 테스트 방식입니다. 즉, 여러 모듈을 함께 테스트해서 정상적인 로직 수행이 가능한지를 확인합니다. 외부 요인들을 포함하고 테스트를 진행하므로 애플리케이션이 온전히 동작하는지를 테스트하게 됩니다. 테스트 비용이 커지는 단점이 있습니다.

## 5. 테스트 코드를 작성하는 방법

1) Given-When-Then 패턴

- Given : 테스트를 수행하기 전에 테스트에 필요한 환경을 설정하는 단계입니다. 테스트에 필요한 변수를 정의하거나 Mock 객체를 통해 특정 상황에 대한 행동을 정의합니다.
- When : 테스트의 목적을 보여주는 단계입니다. 실제 테스트 코드가 포함되며 테스트를 통한 결과 값을 가져오게 됩니다.
- Then : 테스트의 결과를 검증하는 단계입니다. 일반적으로 When 단계에서 나온 결과 값을 검증하는 작업을 수행합니다.

## 6. 좋은 테스트를 작성하는 5가지 속성 (F.I.R.S.T)

- Fast : 테스트는 빠르게 수행돼야 합니다. 외부 환경을 사용하지 않는 단위 테스트를 작성하는 것 등을 빠른 테스트라고 할 수 있습니다.
- Isolated : 하나의 테스트 코드는 하나의 목적으로 여기는 대상에 대해서만 수행돼야 합니다.
- Repeatable : 테스트는 어떤 환경에서도 반복 가능하도록 작성해야 합니다. 개발 환경의 변화나 네트워크의 연결 여부와 상관없이 수행돼야 합니다.
- Self-Validating : 테스트는 그 자체만으로도 테스트의 검증이 완료돼야 합니다. 테스트가 성공했는지 실패했는지 확인할 수 있는 코드를 함께 작성해야 합니다.
- Timely : 테스트 코드는 테스트하려는 애플리케이션 코드를 구현하기 전에 완성돼야 합니다. 

## 7. JUnit을 활용한 테스트 코드 작성

JUnit은 자바 언어에서 사용되는 대표적인 테스트 프레임워크로서 단위 테스트를 위한 도구를 제공합니다. 또한 단위 테스트뿐만 아니라 통합 테스트를 할 수 있는 기능도 제공합니다. JUnit을 사용하면 몇 개의 어노테이션만으로 간편하게 테스트 코드를 작성할 수 있습니다.

## 8. JUnit의 세부 모듈

JUnit 5는 크게 Jupiter, Platform, Vintage의 세 모듈로 구성됩니다.

- Jupiter : 테스트 엔진 API의 구현체를 포함하고 있습니다. 테스트의 실제 구현체는 별도 모듈의 역할을 수행하는데 그중 하나가 Jupiter Engine입니다. Jupiter Engine은 Jupiter API를 활용해서 작성한 테스트 코드를 발견하고 실행하는 역할을 수행합니다.

- Platform : Platform은 JVM에서 테스트를 시작하기 위한 뼈대 역할을 합니다. 테스트를 발견하고 테스트 계획을 생성하는 테스트 엔진의 인터페이스를 가지고 있습니다. 테스트 엔진은 테스트를 발견하고 테스트를 수행하며 그 결과를 보고하는 역할을 수행합니다.

- Vintage : Junit 3, 4에 대한 테스트 엔진 API를 구현하고 있습니다.

## 8. 스프링 부트의 테스트 설정

스프링 부트는 테스트 환경을 쉽게 설정할 수 있게 spring-boot-starter-test 프로젝트를 지원합니다.

spring-boot-starter-test 라이브러리에서 제공하는 대표적인 라이브러리는 다음과 같습니다.

- Junit5 : 자바 애플리케이션의 단위 테스트를 지원합니다.
- Spring Test & Spring Boot Test : 스프링 부트 애플리케이션에 대한 유틸리티와 통합 테스트를 지원합니다.
- AssertJ : 다양한 단정문(assert)을 지원하는 라이브러리입니다.
- Hamcrest : Matcher를 지원하는 라이브러리입니다.
- Mockito: : 자바 Mock 객체를 지원하는 프레임워크입니다.
- JSONassert : JSON용 단정문 라이브러리입니다.
- JsonPath: JSON용 XPath를 지원합니다.

## 9. JUnit의 생명주기

생명주기와 관련되어 테스트 순서에 관여하게 되는 대표적인 어노테이션은 다음과 같습니다.

- @Test : 테스트 코드를 포함한 메서드를 정의합니다.
- @BeforeAll : 테스트를 시작하기 전에 호출되는 메서드를 정의합니다.
- @BeforeEach : 각 테스트 메서드가 실해되기 전에 동작하는 메서드를 정의합니다.
- @AfterAll : 테스트를 종료하면서 호출되는 메서드를 정의합니다.
- @AfterEach : 각 테스트 메서드가 종료되면서 호출되는 메서드를 정의합니다.

## 10. 슬라이스 테스트

슬라이스 테스트는 단위 테스트와 통합 테스트의 중간 개념으로 이해하면 되는데 레이어드 아키텍처를 기준으로 각 레이어별로 나누어 테스트를 진행한다는 의미입니다.

슬라이스 테스트를 위해 사용할 수 있는 대표적인 어노테이션은 다음과 같습니다:

- `@SliceTest`: 슬라이스 테스트 전체를 표시하는 주석입니다.
- `@SliceFixture`: 슬라이스 테스트의 초기 상태를 설정하는 데 사용됩니다.
- `@SliceCase`: 개별 테스트 케이스를 나타냅니다.
- `@SliceInput`: 테스트에 입력으로 사용되는 데이터를 정의하는 데 사용됩니다.
- `@SliceOutput`: 테스트가 예상되는 결과를 지정하는 데 사용됩니다.
- `@SliceExpectation`: 특정 테스트 케이스의 예상 결과를 지정하는 데 사용됩니다.
- `@SliceSetup`: 특정 테스트 케이스 또는 전체 테스트 슬라이스의 설정을 초기화하는 데 사용됩니다.
- `@SliceTearDown`: 특정 테스트 케이스 또는 전체 테스트 슬라이스 이후에 실행되는 정리 코드를 지정하는 데 사용됩니다.
- `@SliceDependency`: 특정 테스트 케이스 또는 전체 테스트 슬라이스가 종속되는 외부 리소스를 지정하는 데 사용됩니다.
- `@SliceTimeout`: 특정 테스트 케이스 또는 전체 테스트 슬라이스에 대한 실행 시간 제한을 설정하는 데 사용됩니다.
- `@SliceSkip`: 특정 테스트 케이스를 건너뛰고자 할 때 사용됩니다.


## 11. JaCoCo를 활용한 테스트 커버리지 확인

코드 커버리지는 소프트웨어의 테스트 수준이 충분한지를 표현하는 지표 중 하나입니다. 테스트를 진행했을 때 대상 코드가 실행됐는지 표현하는 방법으로도 사용됩니다. JaCoCo의 플러그인 설정은 pom.xml 파일에서 합니다.

## 12. 테스트 주도 개발의 효과

- 디버깅 시간 단축 : 문제가 발생 했을 때 어디에서 잘못됐는지 확인하기가 쉽습니다.
- 생산성 향상 : 테스트 코드를 통해 지속적으로 애플리케이션 코드의 불안정성에 대한 피드백을 받기 때문에 리팩토링 횟수가 줄고 생산성이 높아집니다.
- 재설계 시간 단축 : 재설계가 필요할 경우 테스트 코드를 조정하는 것으로 재설계 시간을 단축할 수 있습니다.
- 기능 추가와 같은 추가 구현이 용이 : 테스트 코드를 통해 의도한 기능을 미리 설계하고 코드를 작성하기 때문에 목적에 맞는 코드를 작성하는 데 비교적 용이합니다.
