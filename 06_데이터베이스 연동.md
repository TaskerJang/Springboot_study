# 06_데이터베이스 연동

## 1. 마리아 DB 활용해서 연동하기

- https://mariadb.org/download/ 접속하여 마리아 DB를 다운받기

- 개발환경에 맞춰 설정하고 설치파일을 내려 받기

- 처음 데이터베이스를 설치하면 root계정이 부여됩니다. 그 계정의 패스워드를 지정하는 단계입니다. UTF-8을 기본값으로 설정하기 위해 [Use UTF8 as default server’s character set]에 체크합니다.

- 다음 단계에서는 서버 이름과 포트 번호를 설정해야 합니다. 마리아 DB는 기본 포트번호로 3306을 사용하며 만약 별도로 데이터베이스를 설치한 적이 있다면 포트가 겹치기 때문에 자동으로 3307번으로 매핑 됩니다.

- CREATE DATABASE springboot; => 데이터베이스를 생성하는 쿼리를 입력하고 도구모음 창에 위치한 실행 버튼을 누르면 쿼리가 실행되면서 데이터베이스가 생성됩니다.

## 2. ORM

ORM은 Object Relational Mapping의 줄임말로 객체 관계 매핑을 의미합니다. ORM을 이용하면 쿼리문 작성이 아닌 코드로 데이터를 조작할 수 있습니다.

ORM의 장점

- 쿼리문을 작성하는 양이 현저히 줄어 개발 비용이 줄어 듭니다.

- 객체지향적으로 데이터베이스에 접근할 수 있어 코드의 가독성을 높입니다.

- ORM을 통해 매핑된 객체는 모두 독립적으로 작성되어 있어 재사용이 용이합니다.

- 객체들은 각 클래스로 나뉘어 있어 유지보수가 수월합니다.

- ORM을 통해 자동 생성된 SQL 문은 객체를 기반으로 데이터베이스 테이블을 관리하기 때문에 데이터베이스에 종속적이지 않습니다.

- 데이터베이스를 교체하는 상황에서도 비교적 적은 리스크를 부담합니다.

## 3. JPA

JPA는 Java Persistence API의 줄임말로 자바 진영의 ORM 기술 표준으로 채택된 인터페이스의 모음입니다. ORM이 큰 개념이라면 JPA는 더 구체화된 스펙을 포함합니다. JPA 기반의 구현체는 대표적으로 세 가지가 있습니다. 하이버네이트, 클립스 링크, 데이터 뉴클리어스이며 그중 가장 많이 사용되는 구현체는 하이버네이트입니다.

## 4. 하이버네이트

하이버네이트는 자바의 ORM 프레임워크로 JPA가 정의하는 인터페이스를 구현하고 있는 JPA 구현체 중 하나입니다. 특히, 하이버네이트의 기능을 더욱 편하게 사용하도록 모듈화한 Spring Data JPA가 있습니다. Spring Data JPA는 CRUD 처리에 필요한 인터페이스를 제공하며 하이버네이트에서 자주 사용되는 기능을 더 쉽게 사용할 수 있게 구현한 라이브러리입니다. 

## 5. 영속성 컨텍스트

영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에서 엔티티와 레코드의 괴리를 해소하는 기능과 객체를 보관하는 기능을 수행합니다. 엔티티 객체가 영속성 컨텍스트에 들어오면 JPA는 엔티티 객체의 매핑 정보를 데이터베이스에 반영하는 작업을 수행합니다. 이처럼 엔티티 객체가 영속성 컨텍스트에 들어와 JPA의 관리 대상이 되는 시점부터는 해당 객체를 영속 객체라고 부릅니다. 영속성 컨텍스트는 세션 단위의 생명주기를 가집니다. 데이터베이스에 접근하기 위한 세션이 생성되면 영속성 컨텍스트가 만들어지고, 세션이 종료되면 영속성 컨텍스트도 없어집니다.

엔티티 매니저는 말그대로 엔티티를 관리하는 객체입니다. 엔티티 매니저 팩토리로 생성된 엔티티 매니저는 엔티티를 영속성 컨텍스트에 추가해서 영속 객체로 만드는 작업을 수행하고 영속성 컨텍스트와 데이터베이스를 비교하면서 실제 데이터베이스를 대상으로 작업을 수행합니다. 

## 6. 데이터베이스 연동

프로젝트 생성 후 애플리케이션이 정상적으로 실행될 수 있게 연동할 데이터베이스의 정보를 application.properties에 작성해야 합니다. pom.xml에도 mariadb-java-client 의존성이 필요합니다.

## 7. 엔티티 설계

Spring Data JPA를 사용하면 데이터베이스에 테이블을 생성하기 위해 직접 쿼리를 작성할 필요가 없습니다. 이 기능을 가능하게 하는 것이 엔티티입니다. JPA에서 엔티티는 데이터베이스의 테이블에 대응하는 클래스입니다. 엔티티에는 데이터베이스에 쓰일 테이블과 칼럼을 정의합니다. 엔티티에 어노테이션을 사용하면 테이블 간의 연관관계를 정의할 수 있습니다.

- @Entity : 해당 클래스가 엔티티임을 명시하기 위한 어노테이션입니다. 클래스 자체는 테이블과 일대일로 매칭되며 해당ㅇ 클래스의 인스턴스는 매핑되는 테이블에서 하나의 레코드를 의미합니다.

- @Table : @Table 어노테이션을 사용할 때는 클래스의 이름과 테이블의 이름을 다르게 지정해야 하는 경우입니다. 서로 다른이름을 쓰려면 @Table(name = 값)의 형태로 사용 합니다.

- @Id : 엔티티 클래스의 필드는 테이블의 칼럼과 매핑됩니다. 모든 엔티티는 @Id 어노테이션이 필요합니다.

- @GeneratedValue : 이 어노테이션은 해당 필드의 값을 어ᄄᅠᆫ 방식으로 자동으로 생성할지 결정할 때 사용합니다.

- @Column : name: 데이터베이스의 칼럼명을 설정하는 속성입니다. 명시하지 않으면 필드명으로 지정됩니다. nullable: 레코드를 생성할 때 칼럼 값에 null처리가 가능한지를 명시하는 속성입니다. length: 데이터베이스에 저장하는 데이터의 최대 길이를 설정합니다. unique: 해당 칼럼을 유니크로 설정합니다. @Transient : 엔티티 클래스에는 선언돼 있는 필드지만 데이터베이스에서는 필요 없을 경우 이 어노테이션을 사용해 데이터베이스에서 이용하지 않게 할 수 있습니다.

## 8. 레포지토리 인터페이스 설계

Spring Data JPA는 JpaRepository를 기반으로 더욱 쉽게 데이터베이스를 사용할 수 있는 아키텍처를 제공합니다. 스프링부트로 JpaRepository를 상속하는 인터페이스를 생성하면 기존의 다양한 메서드를 손쉽게 활용할 수 있습니다.

엔티티를 데이터베이스의 테이블과 구조를 생성하는 데 사용했다면 레포지토리는 엔티티가 생성한 데이터베이스에 접근하는 데 사용됩니다. 생성된 레포지토리는 JpaRepository를 상속받으면서 별도의 메서드 구현 없이도 많은 기능을 제공합니다.

레포지토리 메서드의 생성 규칙: 레포지토리에서는 몇 가지 명명규칙에 따라 커스텀 메서드도 생성할 수 있습니다. 일반적으로 CRUD(Create, Read, Update, Delete)에서 따로 생성해서 사용하는 메서드는 대부분 Read부분에 해당하는 Select 쿼리밖에 없습니다. 메서드에 이름을 붙일 때는 첫 단어를 제외한 이후 단어들의 첫 글자를 대문자로 설정해야 JPA에서 정상적으로 인식하고 쿼리를 자동으로 만들어줍니다.

- FindBy: SQL문의 where절 역할을 수행하는 구문입니다. findBy 뒤에 엔티티의 필드값을 입력해서 사용합니다.

- AND, OR : 조건을 여러 개 설정하기 위해 사용합니다.

- Like/ NotLike: SQL문의 like와 동일한 기능을 수행하며 특정 문자를 포함하는지 여부를 조건으로 추가합니다. 비슷한 키워드로 Containing, Contains, isContaining이 있습니다.

- StarwWith/StartingWith: 특정 키워드로 시작하는 문자열 조건을 설정합니다.

- EndsWith/EndingWith: 특정키워드로 끝나는 문자열 조건을 설정합니다.

- IsNull/IsNotNull: 레코드 값이 Null이거나 Null이 아닌 값을 검색합니다.

- True/False: Boolean 타입의 레코드를 검색할 때 사용합니다.

- Before/After: 시간을 기준으로 값을 검색합니다.

- LessThan/GreaterThan: 특정 값을 기준으로 대소 비교를 할 때 사용합니다.

- Between: 두 값 사이의 데이터를 조회합니다.

- OrderBy: SQL 문에서 order by와 동일한 기능을 수행합니다.

- countBy : SQL 문의 count와 동일한 기능을 수행하며 결과값의 개수를 추출합니다.

## 9. DAO 설계

DAO는 Data Access Object의 줄임말로 데이터베이스에 접근하기 위한 로직을 관리하는 객체입니다. 다만 스프링 데이터 JPA에서 DAO의 개념은 레포지토리가 대체하고 있습니다.

DAO 클래스는 일반적으로 ‘인터페이스-구현체’ 구성으로 생성합니다. DAO 클래스는 의존성 결합을 낮추기 위한 디자인 패턴이며 서비스 레이어에 DAO 객체를 주입받을 때 인터페이스를 선언하는 방식으로 구성할 수 있습니다. 

## 10. DAO 연동을 위한 컨트롤러와 서비스 설계

앞에서 설계한 구성 요소들을 클라이언트의 요청과 연결하려면 컨트롤러와 서비스를 생성해야 합니다. 서비스 레이어에서는 도메인 모델을 활용해 애플리케이션에서 제공하는 핵심 기능을 제공합니다.

컨트롤러는 클라이언트로부터 요청을 받고 해당 요청에 대해 서비스 레이어에 구현된 적절한 메서드를 호출해서 결과값을 받습니다. 이처럼 컨트롤러는 요청과 응답을 전달하는 역할만 맡는 것이 좋습니다.

## 11. 반복되는 코드의 작성을 생략하는 방법 – 롬복

롬복은 데이터 클래스를 생성할 때 반복적으로 사용하는 getter/setter 같은 메서드를 어노테이션으로 대체하는 기능을 제공하는 라이브러리입니다. 많은 멤버 변수를 선언하고 각 멤버 변수별로 getter/setter 메서드를 만들어 코드가 길어지고 가독성이 낮아집니다. 이러한 경우 롬복을 활용하면 다음과 같은 장점이 있습니다.

- 어노테이션 기반으로 코드를 자동 생성하므로 생산성이 높아집니다.
- 반복되는 코드를 생략할 수 있어 가독성이 좋아집니다.
- 롬복을 안다면 간단하게 코드를 유추할 수 있어 유지보수에 용이합니다.

롬복의 주요 어노테이션

- @Getter, @Setter : 클래스에 선언돼 있는 필드에 대한 getter/setter 메서드를 생성합니다.

- 생성자 자동 생성 어노테이션: 데이터 클래스의 초기화를 위한 생성자를 자동으로 만들어주는 어노테이션은 다음의 세 가지가 있습니다.

- NoArgsConstructor : 매개변수가 없는 생성자를 자동 생성합니다.

- AllArgsConstructor : 모든 필드를 매개변수로 갖는 생성자를 자동 생성합니다.

- RequiredArgsConstructor: 필드 중 final이나 @NotNull이 설정된 변수를 매개변수로 갖는 생성자를 자동 생성합니다.

- @ToString: 이름 그대로 toString() 메서드를 생성하는 어노테이션입니다. 민감한 정보처럼 숨겨야 할 정보가 있다면 exclude 속성을 사용해 특정필드를 자동생성에서 제외할 수 있습니다.

- @EqualsAndHashCode : equals: 두 객체의 내용이 같은지 동등성을 비교합니다.
  hashCode: 두 객체가 같은 객체인지 동일성을 비교합니다.
  callSuper 속성을 설정하면 부모클래스의 필드를 비교 대상에 포함할 수 있습니다.

- @Data: 앞서 설명한 어노테이션들을 포괄하는 어노테이션입니다. 대부분의 코드가 필요하다면 @Data 어노테이션으로 앞에서 설명한 코드를 전부 한 번에 생성할 수 있습니다. 